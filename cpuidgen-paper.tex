% Encoding: UTF-8
% Build with: pdflatex
% Bibliography engine: bibtex8
% Should be a minimal set of packages and syntax bloat to be able to convert to HTML, RTF etc

\documentclass[a4paper,10pt,oneside,unicode]{article}
\usepackage[top=2cm,left=2.5cm,right=2cm,bottom=3cm]{geometry}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[english]{babel} % no Russian
\usepackage[pdftex]{graphicx}
\usepackage[pdftex]{hyperref}
\usepackage{indentfirst}

\hypersetup{colorlinks=true, linkcolor=black, filecolor=black, urlcolor=black,pdfauthor=Grigory Rechistov <grigory.rechistov@phystech.edu>,pdftitle=Simulation of CPUID of Intel Architecture}

% Extra fancy packages go here
\usepackage{bytefield}

\author{Grigory Rechistov\thanks{Moscow Institute of Physics and Technology, \texttt{grigory.rechistov@phystech.edu}} \and Name Surname\thanks{\texttt{email@mail.com}}}
\title{Simulation of CPUID of Intel Architecture}
\date{\today}

\newcommand{\cpuid}{\textsc{cpuid} }

\newcommand{\todo}[1][]{\textcolor{red}{TODO #1}}
\newcommand{\othercopyright}{\textsuperscript{*}}
\begin{document}

\maketitle

\tableofcontents

\begin{abstract}
    
   \noindent In this paper we give an overview of existing microprocessor features identification facilities. Then we describe our approach to implementation of a software model of Intel IA-32 \cpuid instruction. The described solution allows to define all recent {CPUs}' features, as well as future extensions. Our model was incorporated into the Wind River Simics\othercopyright simulator framework.
    
    \noindent Key words: cpu identification, cpu simulation, CPUID, Simics.
\end{abstract}

\section {Introduction}

\todo{Write me}

\subsection{Contributions}

In this paper we make the following contributions.
\begin{enumerate}
\item Evaluate and compare existing means of processor features identification of different architectures.
\item Describe, implement and evaluate a structured solution to the simulation of \cpuid instruction of Intel IA-32.
\end{enumerate}

\section{Overview of Processor Identification}

This section outlines mechanisms for processor identification offered by several general purpose microprocessor architectures. We do not attempt to give exhaustive descriptions here, but only to reveal data that will allow us to see differences and similarities. More details can be found in documentation to respective architectures.

\subsection{MIPS}

This architecture processor identification with PRid register~\cite{mips-arch}, which is the 15\textsuperscript{th} register in Coprocessor~0. It contains 32 bits of information (Fig.~\ref{fig:mips-prid}), part of which is vendor--specific.

\begin{figure}[htbp]
\bytefieldsetup{bitwidth=0.36cm, endianness = big}
\centering
\begin{bytefield}[]{32}
    \bitheader{31,24,23,16,15,8,7,0} \\
    \bitbox{8}{Company Options} & \bitbox{8}{Company ID} & \bitbox{8}{Processor ID} & \bitbox{8}{Revision}
\end{bytefield}
\caption{MIPS PRid register fields}\label{fig:mips-prid}
\end{figure}

MIPS architecture also implements special register that contains information identifying the capabilities of floating point unit termed Floating Point Implementation Register (FIR)~\cite{mips32-vol1}. It's a read-only 32-bit register (Fig.~\ref{fig:mips-fir})

\begin{figure}[htbp]
\bytefieldsetup{bitwidth=0.5cm, endianness = big}
\centering
\begin{bytefield}[]{32}
    \bitheader{31,28,27,24,23,22,21,20,19,18,17,16,15,8,7,0} \\
    \bitbox{4}{00000} & \bitbox{4}{Impl} & \bitbox{1}{0} & \bitbox{1}{F64} & \bitbox{1}{L} & \bitbox{1}{W} & \bitbox{1}{3D} & \bitbox{1}{PS} & \bitbox{1}{D} & \bitbox{1}{S} & \bitbox{8}{ProcessorID} & \bitbox{8}{Revision}
\end{bytefield}
\caption{MIPS FIR register fields}\label{fig:mips-fir}
\end{figure}

\todo{Check this}

\url{http://hwdb.mipt.cc/MIPS_PRId_register}

\url{http://code.google.com/p/phantomuserland/source/browse/trunk/phantom/dev/mips/cpuid.c?r=1094}

\url{http://www.imgtec.com/mips/mips32-architecture.asp}

\subsection{ARM}

The popular RISC architecture provides certain means of a processor identification with \cpuid base register~\cite{arm-cpuid}. It contains 32 bits of information (Fig.~\ref{fig:arm-cpuid}).

\todo{Chehk this} 

\url{http://infocenter.arm.com/help/topic/com.arm.doc.dai0099c/DAI0099C_core_type_rev_id.pdf}

\url{http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0363e/ch01s11s01.html}

\url{http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0363e/Bcgdjadd.html}

\url{http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0388f/Babififh.html}

\url{http://forum.xda-developers.com/showthread.php?t=480226}

\begin{figure}[htbp]
\bytefieldsetup{bitwidth=0.36cm, endianness = big}
\centering
\begin{bytefield}[]{32}
    \bitheader{31,24,23,20,19,16,15,4,3,0} \\
    \bitbox{8}{Implementer} & \bitbox{4}{Variant} & \bitbox{4}{\texttt{0xC}} & \bitbox{12}{Part No} & \bitbox{4}{Revision}
\end{bytefield}    
\caption{ARM \cpuid{} base register fields}\label{fig:arm-cpuid}
\end{figure}

Examples of values~\cite{xda-arm-id}: Intel (XScale) PXA272 -- 0x69054117, Qualcomm MSM7200A --- 0x4117b362.

\subsection{IBM System z}
IBM System z10~\cite{ibm-system-z10} provides STSI and STIDP instructions. The information is rather scarce on the subject. \todo{Expand}

\subsection{PowerPC}

PowerPC~\cite{powerpc64-arch} offers a 32-bit PVR register that contains just version and revision numbers.

For ISA extensionsm a mechanism of APU (application processor units) is employed. MSR (machine state register) is used to store information of APUs available.

\todo{See also}

\url{http://lxr.linux.no/#linux+v3.13.5/arch/powerpc/kernel/cputable.c#L2245} --- identify\_cpu function

\url{http://cache.freescale.com/files/archives/doc/support_info/PPCPVR.pdf}

\subsection{SPARC}

The SPARC standard~\cite{weaver1994sparc} leaves quite a number of details implementation specific. To distinct between version a 64-bit register VER is defined (Fig.~\ref{fig:sparc-ver}).

\begin{figure}[htbp]
\bytefieldsetup{bitwidth=0.25cm, endianness = big}
\centering
\begin{bytefield}[]{64}
    \bitheader{63,48,47,32,31,24,23,16,15,8,7,5,4,0} \\
    \bitbox{16}{Manufacturer} & \bitbox{16}{Implementation} & \bitbox{8}{Revision} & \bitbox{8}{---} & \bitbox{8}{\footnotesize{Max trap levels}} & \bitbox{3}{---} & \bitbox{5}{\footnotesize{Max window}}
\end{bytefield}
\caption{SPARC VER register}\label{fig:sparc-ver}
\end{figure}

\subsection{Intel IA-64 (Itanium)}

Intel Itanium\texttrademark~\cite{itanium-sdm} was designed later after the original 80x86 series and was meant to supplant it. A set of \cpuid registers is used for identification purposes. The set's design somewhat resembles IA-32 \cpuid instruction (discussed later) --- its register numbers loosely resemble leaves of the latter. Five registers are guaranteed to be present, and bits 0--7 of \cpuid[3] store the actual size of the register set (thus it is limited to 256 entries).

An example of Itanium \cpuid registers content is given on Fig.~\ref{fig:itanium-cpuid}.

\begin{figure}
    \centering
\begin{verbatim}
Leaf              Value
-----------------------
  0  0x49656e69756e6547
0x1          0x6c65746e
0x2                   0
0x3          0x20010104
0x4                 0x5
\end{verbatim}
    
\caption{Contents of \cpuid registers for an Intel Itanium 2 system }\label{fig:itanium-cpuid}
\end{figure} 

% Result of cat /proc/cpuinfo on the Itanium host:
% processor  : 7
% vendor     : GenuineIntel
% arch       : IA-64
% family     : Itanium 2
% model      : 1
% revision   : 1
% archrev    : 0
% features   : branchlong, 16-byte atomic ops
% cpu number : 0
% cpu regs   : 4
% cpu MHz    : 1668.000672
% itc MHz    : 416.667500
% BogoMIPS   : 3325.95
% siblings   : 2
% physical id: 196867
% core id    : 1
% thread id  : 0
%
%uname -a
% Linux host 2.6.18-164.el5 #1 SMP Tue Aug 18 15:54:55 EDT 2009 ia64 ia64 ia64 GNU/Linux
% lsb_release -a
% LSB Version:    :core-3.1-ia64:core-3.1-noarch:graphics-3.1-ia64:graphics-3.1-noarch
% Distributor ID: RedHatEnterpriseServer
% Description:    Red Hat Enterprise Linux Server release 5.4 (Tikanga)
% Release:        5.4
% Codename:       Tikanga


The \texttt{mov =cpuid[...]} instruction is defined to read a processor identification information.

\subsection{Intel IA-32 and Intel 64}

The common PC architecture, starting from Intel Pentium and its clones, provides \cpuid~\cite{intelmanual-7vols, amd-sdm-vol1} instruction. 

Since its inception it has been extended numerous number of times.


On Figure~\ref{fig:real-hw} an output of all defined leaves and subleaves for a modern Intel processor (microarchitecture Ivy Bridge) is demonstrated. The resulting table contains 25 tuples of 4 values of 32 bit width each, total of more than 3 kb of information. Essentially a number of values can be deduced from it.
\begin{itemize}
    \item Processor producer brand (leaf 0) and SKU naming (leaves 0x80000002--0x80000004).
    \item Availablity of ISA extensions such as 64 bit mode, SSEx, AVX, MOVBE etc.
    \item Cache configuration of all layers, both in legacy format (leaf 2) and in current format (leaf 4 with subleaves)
    \item Multi-processor configuration knowledge, such as availability of Intel HyperThreading, relative position inside {CPU} package (topology), presence of {APIC} (interrupt controller)
    \item Numerous architectural varaibles, such as addresses widths (leaf 0x80000008), availability of dynamic frequency scaling etc.
\end{itemize}


\begin{figure}[htbp]
\centering
\begin{verbatim}
Leaf             Subleaf         EAX         EBX        ECX          EDX
------------------------------------------------------------------------
           0           0         0xd  0x756e6547  0x6c65746e  0x49656e69
         0x1           0     0x306a9   0x6100800  0x7f9ae3bf  0xbfebfbff
         0x2           0  0x76035a01    0xf0b0ff           0    0xca0000
         0x4           0  0x1c004121   0x1c0003f        0x3f           0
         0x4         0x1  0x1c004122   0x1c0003f        0x3f           0
         0x4         0x2  0x1c004143   0x1c0003f       0x1ff           0
         0x4         0x3  0x1c03c163   0x2c0003f      0x1fff         0x6
         0x5           0        0x40        0x40         0x3      0x1120
         0x6           0        0x77         0x2         0x9           0
         0x7           0           0       0x281           0           0
         0xa           0   0x7300803           0           0       0x603
         0xb           0         0x1         0x1       0x100         0x6
         0xb         0x1         0x4         0x4       0x201         0x6
         0xb         0x2           0           0         0x2         0x6
         0xb         0x3           0           0         0x3         0x6
         0xd           0         0x7       0x340       0x340           0
         0xd         0x1         0x1           0           0           0
         0xd         0x2       0x100       0x240           0           0
  0x80000000           0  0x80000008           0           0           0
  0x80000001           0           0           0         0x1  0x28100800
  0x80000002           0  0x20202020  0x20202020  0x65746e49  0x2952286c
  0x80000003           0  0x726f4320  0x4d542865  0x35692029  0x3534332d
  0x80000004           0  0x50432030  0x20402055  0x30312e33    0x7a4847
  0x80000006           0           0           0   0x1006040           0
  0x80000007           0           0           0           0       0x100
  0x80000008           0      0x3024           0           0           0
\end{verbatim}

    \caption{Output of \cpuid instruction obtained for Intel\textregistered Core\texttrademark i5-3450 using \texttt{ggg-cpuid}~\cite{ggg-cpuid}}\label{fig:real-hw}
\end{figure}

\subsection{Comparison of Processor Identification}

Based on the presented data several conclusions can be made.
\begin{itemize}
    \item {CPU} identification facilities differ greatly between architectures. They may be represented by instructions, registers, or groups of both.
    \item The most common thing that can be specified through a \cpuid is a vendor identification. The next on popularity is indication of ISA extensions.
    
    \item The complexity/completeness of \cpuid facilities depends on whether there are requirements to run the same binary code on hardware from multiple vendors and/or of different generations. If, in order to perform efficiently, software must “know” a list of supported instruction extensions and other types of model specific configuration, there has to be a documented way to obtain such knowledge.
    \item Conversely, {CPUs} provided by a single vendor and/or designed for specific software usually provide less means of self-identification. Most microcontrollers for embedded applications hardly provide even an idea of \cpuid, compared to general purpose processors, because software is often written to be run on a specific HW; binaries are not meant to be moved to some other incarnation of the same architecture.
    
%     \item It is basically hard to define completely what identification facilities should store.
\end{itemize}

\section{What is so hard about Intel CPUID}

We now concentrate solely on the Intel IA-32 architecture and the single \cpuid instruction. A complete definition of \cpuid in~\cite{intelmanual-7vols} takes about 40 pages.

There is a number of complications that have resulted from long uncontrolled expansion of the \cpuid.

\paragraph{Influence of Multiple Vendors} Until recently, there were numerous {CPU} vendors that offered processors compatible with Intel architecture, including IBM, Cyrix, VIA, Centaur, Transmeta etc. By 2014, only two companies remain --- Intel itself and AMD. Competition lead to the numerous small and subtle but essential differences in implementation. Until \cpuid was introduced, 

In the past, a robust identification of IA-32 processor brand and model required surprisingly intricate methods~\cite{cpuid-wars}. At present times, things are somewhat well documented. But then, another

\paragraph{Long history that lead to extremely long list of extensions.} With 40 years of backwards-compatible development the IA-32 architecture collected a number of additions. Consider a list of flags which a modern GNU/Linux operating system shows for a \cpuid of the laptop this paper is being written on (Fig.~\ref{fig:flags}). It should be noted that only a part of information from \cpuid is actually present on this list.

\begin{figure}
\noindent\texttt{flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx rdtscp lm constant\_tsc arch\_perfmon pebs bts nopl xtopology nonstop\_tsc aperfmperf pni pclmulqdq dtes64 monitor ds\_cpl vmx est tm2 ssse3 cx16 xtpr pdcm pcid sse4\_1 sse4\_2 x2apic popcnt tsc\_deadline\_timer xsave avx lahf\_lm arat epb xsaveopt pln pts dtherm tpr\_shadow vnmi flexpriority ept vpid
}
\caption{Part of output of \texttt{cat /proc/cpuinfo} command on GNU/Linux on a recent Intel IA-32 {CPU}}\label{fig:flags}
\end{figure} 

Now, moving to details of \cpuid operation, we will show more complexity that arises from the semantics of \cpuid instruction.

\paragraph{Elements adressing}

To inspect a value of a particular
\begin{itemize}
\item Leaves
\item Subleaves
\item Registers
\item Bit range
\end{itemize}

\paragraph{Non-constant values} Firmware is able to suppress certain features indicated by \cpuid by manipulating bits of model specific register (MSR) IA32\_MISC\_ENABLE. CPUID leaves more than \texttt{0x3} and less than \texttt{0x80000000} are visible only when IA32\_MISC\_ENABLE.BOOT\_NT4[bit 22] is clear. For example, operating system of BIOS may disable MWAIT instruction by using IA32\_MISC\_ENABLE MSR; disabling MWAIT also clears corresponding CPUID feature flag. Software is also able to manage several architecture extensions and CPUID flags using control register CR4. For example operating system can set OSXSAVE flag to indicate that use of \texttt{XGETBV}, \texttt{XSAVE} and \texttt{XRSTOR} instructions is supported by general software.

\paragraph{Topology-varaible elements}

Finally, it should be noted that, besides EAX, EBX, ECX, EDX, one more register may be affected by \cpuid, namely IA32\_SIGNATURE \todo.

\section{Existing Approaches to CPUID Simulation}

Every software simulator, emulator or virtual machine of a recent (Pentium or later) IA-32 system must guarantee \cpuid operation of certain accuracyIf such tool is used for system firmware development, which is even more sensitive to identification information, the following requirements should be.
\begin{itemize}
\item Be accurate \todo
\item Be configurable \todo
\end{itemize}

\subsection{Bochs}

Bochs~\cite{bochs} \todo 

\subsection{Xen}

Xen~\cite{xen2006} \todo 

\subsection{Qemu}

Qemu~\cite{qemu} \todo 

\subsection{Simics}

Wind River Simics~\cite{simics} \todo

\section{The Structured Approach}

The described approach

It has the following advantages

\begin{itemize}
\item Uses natural unit of configuration state --- a field.
\item In the meantime, it allows its users to operate in terms of 32 bit leaves values which are more convenient and compact in many cases.
\item
\end{itemize}



\section{Evaluation}

\subsection{Compatibility with existing code}

“legacy” 

\subsection{Extensions}

\todo Field flags, such as “hidden”.

\section{Conclusions}

In this paper we described our approach to simulation of a single but complex processor instruction \cpuid. 

\paragraph{Model specific registers.} Besides \cpuid, processors of Intel architecture may have a quite extensive of model specific registers (MSRs), which can be read/written with \textsc{rdmsr/wrmsr} instructions, and also contain bits of processor identification. The simulation of MSRs is also an important aspect, but it is out of this paper focus. Other architectures may have similar facilities, e.g. special purpose registers (SPRs) in PowerPC. 



\section{Acknowledgements}
Thanks to my parents for raising an awesome me.

\bibliographystyle{plain}
\bibliography{art} % use bibtex8, NO SPACES HERE!

\end{document}
